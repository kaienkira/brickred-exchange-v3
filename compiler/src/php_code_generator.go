package main

import (
	"fmt"
	"path/filepath"
	"strings"
)

type PhpCodeGenerator struct {
	BaseCodeGenerator
}

func NewPhpCodeGenerator() *PhpCodeGenerator {
	newObj := new(PhpCodeGenerator)

	return newObj
}

func (this *PhpCodeGenerator) Close() {
	this.close()
}

func (this *PhpCodeGenerator) Generate(
	descriptor *ProtocolDescriptor,
	outputDir string, newLineType NewLineType) bool {

	this.init(descriptor, newLineType)

	sourceFilePath := filepath.Join(
		outputDir, this.descriptor.ProtoDef.Name+".php")
	sourceFileContent := this.generateSourceFile()
	if utilWriteAllText(sourceFilePath, sourceFileContent) == false {
		return false
	}

	return true
}

func (this *PhpCodeGenerator) getEnumItemFullQualifiedName(
	enumItemDef *EnumItemDef) string {

	enumDef := enumItemDef.ParentRef
	protoDef := enumDef.ParentRef
	namespaceDef, ok := protoDef.Namespaces["php"]
	if ok {
		return fmt.Sprintf(
			"\\%s\\%s::%s",
			strings.Join(namespaceDef.NamespaceParts, "\\"),
			enumDef.Name,
			enumItemDef.Name)
	} else {
		return fmt.Sprintf(
			"%s::%s",
			enumDef.Name,
			enumItemDef.Name)
	}
}

func (this *PhpCodeGenerator) getStructFullQualifiedName(
	structDef *StructDef) string {

	protoDef := structDef.ParentRef
	namespaceDef, ok := protoDef.Namespaces["php"]
	if ok {
		return fmt.Sprintf(
			"\\%s\\%s",
			strings.Join(namespaceDef.NamespaceParts, "\\"),
			structDef.Name)
	} else {
		return structDef.Name
	}
}

func (this *PhpCodeGenerator) getStructFieldPhpTypeDefaultValue(
	fieldDef *StructFieldDef) string {

	checkType := fieldDef.Type

	if checkType == StructFieldType_I8 ||
		checkType == StructFieldType_U8 ||
		checkType == StructFieldType_I16 ||
		checkType == StructFieldType_U16 ||
		checkType == StructFieldType_I32 ||
		checkType == StructFieldType_U32 ||
		checkType == StructFieldType_I16V ||
		checkType == StructFieldType_U16V ||
		checkType == StructFieldType_I32V ||
		checkType == StructFieldType_U32V {
		return "0"
	} else if checkType == StructFieldType_I64 ||
		checkType == StructFieldType_I64V {
		return "new Int64()"
	} else if checkType == StructFieldType_U64 ||
		checkType == StructFieldType_U64V {
		return "new UInt64()"
	} else if checkType == StructFieldType_String ||
		checkType == StructFieldType_Bytes {
		return "''"
	} else if checkType == StructFieldType_Bool {
		return "false"
	} else if checkType == StructFieldType_Enum {
		if len(fieldDef.RefEnumDef.Items) > 0 {
			return this.getEnumItemFullQualifiedName(
				fieldDef.RefEnumDef.Items[0])
		} else {
			return "0"
		}
	} else if checkType == StructFieldType_Struct {
		return fmt.Sprintf("new %s()",
			this.getStructFullQualifiedName(fieldDef.RefStructDef))
	} else if checkType == StructFieldType_List {
		return "[]"
	} else {
		return ""
	}
}

func (this *PhpCodeGenerator) generateSourceFile() string {
	var sb strings.Builder

	this.writePhpTagStart(&sb)
	this.writeDontEditComment(&sb)
	this.writeNamespaceDecl(&sb)
	this.writeUseStatementsDecl(&sb)
	this.writeEnumDecl(&sb)
	this.writeStructDecl(&sb)
	this.writeEnumMapDecl(&sb)
	this.writePhpTagEnd(&sb)

	return sb.String()
}

func (this *PhpCodeGenerator) writePhpTagStart(
	sb *strings.Builder) {

	this.writeLine(sb,
		"<?php")
}

func (this *PhpCodeGenerator) writePhpTagEnd(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"/* end of %s.php */",
		protoDef.Name)
}

func (this *PhpCodeGenerator) writeDontEditComment(
	sb *strings.Builder) {

	this.writeLine(sb,
		"/*")
	this.writeLine(sb,
		" * Generated by brickred exchange compiler.")
	this.writeLine(sb,
		" * Do not edit unless you are sure that you know what you are doing.")
	this.writeLine(sb,
		" */")
}

func (this *PhpCodeGenerator) writeNamespaceDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	namespaceDef, ok := protoDef.Namespaces["php"]
	if ok == false {
		return
	}
	namespaceName := strings.Join(namespaceDef.NamespaceParts, "\\")

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"namespace %s;",
		namespaceName)
}

func (this *PhpCodeGenerator) writeUseStatementsDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	useBrickredExchangeCodec := false
	useBrickredExchangeInt64 := false
	useBrickredExchangeUInt64 := false

	for _, structDef := range protoDef.Structs {
		if len(structDef.Fields) > 0 {
			useBrickredExchangeCodec = true
		}
		for _, def := range structDef.Fields {
			if def.Type == StructFieldType_I64 ||
				def.Type == StructFieldType_I64V {
				useBrickredExchangeInt64 = true
			} else if def.Type == StructFieldType_U64 ||
				def.Type == StructFieldType_U64V {
				useBrickredExchangeUInt64 = true
			}
		}
	}

	if useBrickredExchangeCodec == false &&
		useBrickredExchangeInt64 == false &&
		useBrickredExchangeUInt64 == false {
		return
	}

	this.writeEmptyLine(sb)
	if useBrickredExchangeCodec {
		this.writeLine(sb,
			"use \\Brickred\\Exchange\\Codec;")
	}
	if useBrickredExchangeInt64 {
		this.writeLine(sb,
			"use \\Brickred\\Exchange\\Int64;")
	}
	if useBrickredExchangeUInt64 {
		this.writeLine(sb,
			"use \\Brickred\\Exchange\\UInt64;")
	}
}

func (this *PhpCodeGenerator) writeEnumDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	for _, def := range protoDef.Enums {
		this.writeOneEnumDecl(sb, def)
	}
}

func (this *PhpCodeGenerator) writeOneEnumDecl(
	sb *strings.Builder, enumDef *EnumDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"final class %s",
		enumDef.Name)
	this.writeLine(sb,
		"{")

	for _, def := range enumDef.Items {
		if def.Type == EnumItemType_Default ||
			def.Type == EnumItemType_Int {
			this.writeLineFormat(sb,
				"    const %s = %d;",
				def.Name, def.IntValue)
		} else if def.Type == EnumItemType_CurrentEnumRef {
			this.writeLineFormat(sb,
				"    const %s = self::%s;",
				def.Name, def.RefEnumItemDef.Name)
		} else if def.Type == EnumItemType_OtherEnumRef {
			this.writeLineFormat(sb,
				"    const %s = %s;",
				def.Name,
				this.getEnumItemFullQualifiedName(def.RefEnumItemDef))
		}
	}

	this.writeLine(sb,
		"}")
}

func (this *PhpCodeGenerator) writeStructDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	for _, def := range protoDef.Structs {
		this.writeOneStructDecl(sb, def)
	}
}

func (this *PhpCodeGenerator) writeOneStructDecl(
	sb *strings.Builder, structDef *StructDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"final class %s",
		structDef.Name)
	this.writeLine(sb,
		"{")
	this.writeOneStructDeclFieldDecl(sb, structDef)
	this.writeOneStructDeclConstructor(sb, structDef)
	this.writeOneStructDeclEncodeFunc(sb, structDef)
	this.writeOneStructDeclDecodeFunc(sb, structDef)
	this.writeOneStructDeclToArrayFunc(sb, structDef)
	this.writeOneStructDeclFromArrayFunc(sb, structDef)
	this.writeOneStructDeclJsonFunc(sb)
	this.writeOneStructDeclOptionalFunc(sb, structDef)
	this.writeLine(sb,
		"}")
}

func (this *PhpCodeGenerator) writeOneStructDeclFieldDecl(
	sb *strings.Builder, structDef *StructDef) {

	if structDef.OptionalFieldCount > 0 {
		this.writeLineFormat(sb,
			"    private $_has_bits_;")
	}

	for _, def := range structDef.Fields {
		this.writeLineFormat(sb,
			"    public $%s;",
			def.Name)
	}
}

func (this *PhpCodeGenerator) writeOneStructDeclConstructor(
	sb *strings.Builder, structDef *StructDef) {

	if len(structDef.Fields) > 0 {
		this.writeEmptyLine(sb)
	}
	this.writeLine(sb,
		"    public function __construct()")
	this.writeLine(sb,
		"    {")

	if structDef.OptionalFieldCount > 0 {
		zeroList := strings.Repeat("0, ", structDef.OptionalByteCount)
		zeroList = zeroList[:len(zeroList)-2]
		this.writeLineFormat(sb,
			"        $this->_has_bits_ = [%s];",
			zeroList)
	}

	for _, def := range structDef.Fields {
		this.writeLineFormat(sb,
			"        $this->%s = %s;",
			def.Name,
			this.getStructFieldPhpTypeDefaultValue(def))
	}

	this.writeLine(sb,
		"    }")
}

func (this *PhpCodeGenerator) writeOneStructDeclEncodeFunc(
	sb *strings.Builder, structDef *StructDef) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public function encode()")
	this.writeLine(sb,
		"    {")

	if len(structDef.Fields) <= 0 {
		this.writeLine(sb,
			"        return '';")
	} else {
		this.writeLine(sb,
			"        $output = '';")
		this.writeEmptyLine(sb)

		if structDef.OptionalByteCount > 0 {
			this.writeLineFormat(sb,
				"        for ($i = 0; $i < %d; ++$i) {",
				structDef.OptionalByteCount)
			this.writeLine(sb, "            "+
				"$output .= Codec::writeInt8($this->_has_bits_[$i]);")
			this.writeLine(sb,
				"        }")
			this.writeEmptyLine(sb)
		}

		for _, def := range structDef.Fields {
			this.writeOneStructDeclEncodeFuncWriteStatement(sb, def)
		}

		this.writeEmptyLine(sb)
		this.writeLine(sb,
			"        return $output;")
	}

	this.writeLine(sb,
		"    }")
}

func (this *PhpCodeGenerator) writeOneStructDeclEncodeFuncWriteStatement(
	sb *strings.Builder, fieldDef *StructFieldDef) {

	if fieldDef.IsOptional {
		this.writeLineFormat(sb,
			"        if ($this->has_%s()) {",
			fieldDef.Name)
	}

	isList := fieldDef.Type == StructFieldType_List
	var checkType StructFieldType
	if fieldDef.Type == StructFieldType_List {
		checkType = fieldDef.ListType
	} else {
		checkType = fieldDef.Type
	}

	var writeFunc string
	if checkType == StructFieldType_I8 ||
		checkType == StructFieldType_U8 ||
		checkType == StructFieldType_Bool {
		writeFunc = "writeInt8"
	} else if checkType == StructFieldType_I16 ||
		checkType == StructFieldType_U16 {
		writeFunc = "writeInt16"
	} else if checkType == StructFieldType_I32 ||
		checkType == StructFieldType_U32 {
		writeFunc = "writeInt32"
	} else if checkType == StructFieldType_I64 ||
		checkType == StructFieldType_U64 {
		writeFunc = "writeInt64"
	} else if checkType == StructFieldType_I16V ||
		checkType == StructFieldType_U16V {
		writeFunc = "writeInt16V"
	} else if checkType == StructFieldType_I32V ||
		checkType == StructFieldType_U32V ||
		checkType == StructFieldType_Enum {
		writeFunc = "writeInt32V"
	} else if checkType == StructFieldType_I64V ||
		checkType == StructFieldType_U64V {
		writeFunc = "writeInt64V"
	} else if checkType == StructFieldType_String ||
		checkType == StructFieldType_Bytes {
		writeFunc = "writeString"
	} else if checkType == StructFieldType_Struct {
		writeFunc = "writeStruct"
	}

	var indent string
	if fieldDef.IsOptional {
		indent = "            "
	} else {
		indent = "        "
	}
	if isList {
		this.writeLineFormat(sb,
			"%s$output .= Codec::writeList($this->%s, '%s');",
			indent, fieldDef.Name, writeFunc)
	} else {
		this.writeLineFormat(sb,
			"%s$output .= Codec::%s($this->%s);",
			indent, writeFunc, fieldDef.Name)
	}

	if fieldDef.IsOptional {
		this.writeLine(sb,
			"        }")
	}
}

func (this *PhpCodeGenerator) writeOneStructDeclDecodeFunc(
	sb *strings.Builder, structDef *StructDef) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public function decodeFromStream($s)")
	this.writeLine(sb,
		"    {")

	if len(structDef.Fields) > 0 {
		if structDef.OptionalByteCount > 0 {
			this.writeLineFormat(sb,
				"        for ($i = 0; $i < %d; ++$i) {",
				structDef.OptionalByteCount)
			this.writeLine(sb,
				"            $this->_has_bits_[$i] = Codec::readUint8($s);")
			this.writeLine(sb,
				"        }")
			this.writeEmptyLine(sb)
		}

		for _, def := range structDef.Fields {
			this.writeOneStructDeclDecodeFuncReadStatement(sb, def)
		}
	}

	this.writeLine(sb,
		"    }")

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public function decode($buf)")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        $s = Codec::openStreamForBuffer($buf);")
	this.writeLine(sb,
		"        $this->decodeFromStream($s);")
	this.writeLine(sb,
		"        fclose($s);")
	this.writeLine(sb,
		"    }")
}

func (this *PhpCodeGenerator) writeOneStructDeclDecodeFuncReadStatement(
	sb *strings.Builder, fieldDef *StructFieldDef) {

	if fieldDef.IsOptional {
		this.writeLineFormat(sb,
			"        if ($this->has_%s()) {",
			fieldDef.Name)
	}

	isList := fieldDef.Type == StructFieldType_List
	var checkType StructFieldType
	if fieldDef.Type == StructFieldType_List {
		checkType = fieldDef.ListType
	} else {
		checkType = fieldDef.Type
	}

	var readFunc string
	if checkType == StructFieldType_I8 {
		readFunc = "readInt8"
	} else if checkType == StructFieldType_U8 {
		readFunc = "readUInt8"
	} else if checkType == StructFieldType_I16 {
		readFunc = "readInt16"
	} else if checkType == StructFieldType_U16 {
		readFunc = "readUInt16"
	} else if checkType == StructFieldType_I32 {
		readFunc = "readInt32"
	} else if checkType == StructFieldType_U32 {
		readFunc = "readUInt32"
	} else if checkType == StructFieldType_I64 {
		readFunc = "readInt64"
	} else if checkType == StructFieldType_U64 {
		readFunc = "readUInt64"
	} else if checkType == StructFieldType_I16V {
		readFunc = "readInt16V"
	} else if checkType == StructFieldType_U16V {
		readFunc = "readUInt16V"
	} else if checkType == StructFieldType_I32V ||
		checkType == StructFieldType_Enum {
		readFunc = "readInt32V"
	} else if checkType == StructFieldType_U32V {
		readFunc = "readUInt32V"
	} else if checkType == StructFieldType_I64V {
		readFunc = "readInt64V"
	} else if checkType == StructFieldType_U64V {
		readFunc = "readUInt64V"
	} else if checkType == StructFieldType_String ||
		checkType == StructFieldType_Bytes {
		readFunc = "readString"
	} else if checkType == StructFieldType_Bool {
		readFunc = "readBool"
	}

	var indent string
	if fieldDef.IsOptional {
		indent = "            "
	} else {
		indent = "        "
	}
	if isList {
		if checkType == StructFieldType_Struct {
			this.writeLineFormat(sb,
				"%s$this->%s = Codec::readStructList($s, '%s');",
				indent, fieldDef.Name,
				this.getStructFullQualifiedName(fieldDef.RefStructDef))
		} else {
			this.writeLineFormat(sb,
				"%s$this->%s = Codec::readList($s, '%s');",
				indent, fieldDef.Name, readFunc)
		}
	} else {
		if checkType == StructFieldType_Struct {
			this.writeLineFormat(sb,
				"%s$this->%s = Codec::readStruct($s, '%s');",
				indent, fieldDef.Name,
				this.getStructFullQualifiedName(fieldDef.RefStructDef))
		} else {
			this.writeLineFormat(sb,
				"%s$this->%s = Codec::%s($s);",
				indent, fieldDef.Name, readFunc)
		}
	}

	if fieldDef.IsOptional {
		this.writeLine(sb,
			"        }")
	}
}

func (this *PhpCodeGenerator) writeOneStructDeclToArrayFunc(
	sb *strings.Builder, structDef *StructDef) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public function toArray()")
	this.writeLine(sb,
		"    {")

	if len(structDef.Fields) <= 0 {
		this.writeLine(sb,
			"        return [];")
	} else {
		this.writeLine(sb,
			"        $output = [];")
		this.writeEmptyLine(sb)

		for _, def := range structDef.Fields {
			this.writeOneStructDeclToArrayFuncWriteStatement(sb, def)
		}

		this.writeEmptyLine(sb)
		this.writeLine(sb,
			"        return $output;")
	}

	this.writeLine(sb,
		"    }")
}

func (this *PhpCodeGenerator) writeOneStructDeclToArrayFuncWriteStatement(
	sb *strings.Builder, fieldDef *StructFieldDef) {

	if fieldDef.IsOptional {
		this.writeLineFormat(sb,
			"        if ($this->has_%s()) {",
			fieldDef.Name)
	}

	isList := fieldDef.Type == StructFieldType_List
	var checkType StructFieldType
	if fieldDef.Type == StructFieldType_List {
		checkType = fieldDef.ListType
	} else {
		checkType = fieldDef.Type
	}

	var indent string
	if fieldDef.IsOptional {
		indent = "            "
	} else {
		indent = "        "
	}

	if checkType == StructFieldType_I8 ||
		checkType == StructFieldType_U8 ||
		checkType == StructFieldType_I16 ||
		checkType == StructFieldType_U16 ||
		checkType == StructFieldType_I32 ||
		checkType == StructFieldType_U32 ||
		checkType == StructFieldType_I16V ||
		checkType == StructFieldType_U16V ||
		checkType == StructFieldType_I32V ||
		checkType == StructFieldType_U32V ||
		checkType == StructFieldType_String ||
		checkType == StructFieldType_Bool ||
		checkType == StructFieldType_Enum {
		this.writeLineFormat(sb,
			"%s$output['%s'] = $this->%s;",
			indent, fieldDef.Name, fieldDef.Name)
	} else if checkType == StructFieldType_Bytes {
		if isList {
			this.writeLineFormat(sb,
				"%s$output['%s'] = [];",
				indent, fieldDef.Name)
			this.writeLineFormat(sb,
				"%sfor ($i = 0; $i < count($this->%s); ++$i) {",
				indent, fieldDef.Name)
			this.writeLineFormat(sb,
				"%s    $output['%s'][$i] = base64_encode($this->%s[$i]);",
				indent, fieldDef.Name, fieldDef.Name)
			this.writeLineFormat(sb,
				"%s}",
				indent)
		} else {
			this.writeLineFormat(sb,
				"%s$output['%s'] = base64_encode($this->%s);",
				indent, fieldDef.Name, fieldDef.Name)
		}
	} else if checkType == StructFieldType_I64 ||
		checkType == StructFieldType_U64 ||
		checkType == StructFieldType_I64V ||
		checkType == StructFieldType_U64V {
		if isList {
			this.writeLineFormat(sb,
				"%s$output['%s'] = [];",
				indent, fieldDef.Name)
			this.writeLineFormat(sb,
				"%sfor ($i = 0; $i < count($this->%s); ++$i) {",
				indent, fieldDef.Name)
			this.writeLineFormat(sb,
				"%s    $output['%s'][$i] = $this->%s[$i]->toString();",
				indent, fieldDef.Name, fieldDef.Name)
			this.writeLineFormat(sb,
				"%s}",
				indent)
		} else {
			this.writeLineFormat(sb,
				"%s$output['%s'] = $this->%s->toString();",
				indent, fieldDef.Name, fieldDef.Name)
		}
	} else if checkType == StructFieldType_Struct {
		if isList {
			this.writeLineFormat(sb,
				"%s$output['%s'] = [];",
				indent, fieldDef.Name)
			this.writeLineFormat(sb,
				"%sfor ($i = 0; $i < count($this->%s); ++$i) {",
				indent, fieldDef.Name)
			this.writeLineFormat(sb,
				"%s    $output['%s'][$i] = $this->%s[$i]->toArray();",
				indent, fieldDef.Name, fieldDef.Name)
			this.writeLineFormat(sb,
				"%s}",
				indent)
		} else {
			this.writeLineFormat(sb,
				"%s$output['%s'] = $this->%s->toArray();",
				indent, fieldDef.Name, fieldDef.Name)
		}
	}

	if fieldDef.IsOptional {
		this.writeLine(sb,
			"        }")
	}
}

func (this *PhpCodeGenerator) writeOneStructDeclFromArrayFunc(
	sb *strings.Builder, structDef *StructDef) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public function fromArray($arr)")
	this.writeLine(sb,
		"    {")

	if len(structDef.Fields) > 0 {
		if structDef.OptionalByteCount > 0 {
			this.writeLineFormat(sb,
				"        for ($i = 0; $i < %d; ++$i) {",
				structDef.OptionalByteCount)
			this.writeLine(sb,
				"            $this->_has_bits_[$i] = 0;")
			this.writeLine(sb,
				"        }")
			this.writeEmptyLine(sb)
		}

		for _, def := range structDef.Fields {
			this.writeOneStructDeclFromArrayFuncReadStatement(sb, def)
		}
	}

	this.writeLine(sb,
		"    }")
}

func (this *PhpCodeGenerator) writeOneStructDeclFromArrayFuncReadStatement(
	sb *strings.Builder, fieldDef *StructFieldDef) {

	if fieldDef.IsOptional {
		this.writeLineFormat(sb,
			"        if (isset($arr['%s'])) {",
			fieldDef.Name)
		this.writeLineFormat(sb,
			"            $this->set_has_%s();",
			fieldDef.Name)
	}

	isList := fieldDef.Type == StructFieldType_List
	var checkType StructFieldType
	if fieldDef.Type == StructFieldType_List {
		checkType = fieldDef.ListType
	} else {
		checkType = fieldDef.Type
	}

	var readFunc string
	if checkType == StructFieldType_I8 ||
		checkType == StructFieldType_U8 ||
		checkType == StructFieldType_I16 ||
		checkType == StructFieldType_U16 ||
		checkType == StructFieldType_I32 ||
		checkType == StructFieldType_U32 ||
		checkType == StructFieldType_I16V ||
		checkType == StructFieldType_U16V ||
		checkType == StructFieldType_I32V ||
		checkType == StructFieldType_U32V ||
		checkType == StructFieldType_Enum {
		readFunc = "readIntFromArray"
	} else if checkType == StructFieldType_I64 ||
		checkType == StructFieldType_I64V {
		readFunc = "readInt64FromArray"
	} else if checkType == StructFieldType_U64 ||
		checkType == StructFieldType_U64V {
		readFunc = "readUInt64FromArray"
	} else if checkType == StructFieldType_String {
		readFunc = "readStringFromArray"
	} else if checkType == StructFieldType_Bytes {
		readFunc = "readBytesFromArray"
	} else if checkType == StructFieldType_Bool {
		readFunc = "readBoolFromArray"
	}

	var indent string
	if fieldDef.IsOptional {
		indent = "            "
	} else {
		indent = "        "
	}
	if isList {
		if checkType == StructFieldType_Struct {
			this.writeLineFormat(sb, ""+
				"%s$this->%s = Codec::readStructListFromArray("+
				"$arr, '%s', '%s');",
				indent, fieldDef.Name, fieldDef.Name,
				this.getStructFullQualifiedName(fieldDef.RefStructDef))
		} else {
			this.writeLineFormat(sb, ""+
				"%s$this->%s = Codec::readListFromArray("+
				"$arr, '%s', '%s');",
				indent, fieldDef.Name, fieldDef.Name, readFunc)
		}
	} else {
		if checkType == StructFieldType_Struct {
			this.writeLineFormat(sb, ""+
				"%s$this->%s = Codec::readStructFromArray("+
				"$arr, '%s', '%s');",
				indent, fieldDef.Name, fieldDef.Name,
				this.getStructFullQualifiedName(fieldDef.RefStructDef))
		} else {
			this.writeLineFormat(sb,
				"%s$this->%s = Codec::%s($arr, '%s');",
				indent, fieldDef.Name, readFunc, fieldDef.Name)
		}
	}

	if fieldDef.IsOptional {
		this.writeLine(sb,
			"        }")
	}
}

func (this *PhpCodeGenerator) writeOneStructDeclJsonFunc(
	sb *strings.Builder) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public function toJson()")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        return json_encode($this->toArray());")
	this.writeLine(sb,
		"    }")

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public function fromJson($json)")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        $this->fromArray(json_decode($json, true));")
	this.writeLine(sb,
		"    }")
}

func (this *PhpCodeGenerator) writeOneStructDeclOptionalFunc(
	sb *strings.Builder, structDef *StructDef) {

	if structDef.OptionalFieldCount <= 0 {
		return
	}

	for _, def := range structDef.Fields {
		if def.IsOptional == false {
			continue
		}

		byteIndex := def.OptionalFieldIndex / 8
		byteMask := fmt.Sprintf("0x%02x", 1<<(def.OptionalFieldIndex%8))

		this.writeEmptyLine(sb)
		this.writeLineFormat(sb,
			"    public function has_%s()",
			def.Name)
		this.writeLine(sb,
			"    {")
		this.writeLineFormat(sb,
			"        return (bool)($this->_has_bits_[%d] & %s);",
			byteIndex, byteMask)
		this.writeLine(sb,
			"    }")

		this.writeEmptyLine(sb)
		this.writeLineFormat(sb,
			"    public function set_has_%s()",
			def.Name)
		this.writeLine(sb,
			"    {")
		this.writeLineFormat(sb,
			"        $this->_has_bits_[%d] |= %s;",
			byteIndex, byteMask)
		this.writeLine(sb,
			"    }")

		this.writeEmptyLine(sb)
		this.writeLineFormat(sb,
			"    public function clear_has_%s()",
			def.Name)
		this.writeLine(sb,
			"    {")
		this.writeLineFormat(sb,
			"        $this->_has_bits_[%d] &= ~%s;",
			byteIndex, byteMask)
		this.writeLine(sb,
			"    }")

		this.writeEmptyLine(sb)
		this.writeLineFormat(sb,
			"    public function set_%s($value)",
			def.Name)
		this.writeLine(sb,
			"    {")
		this.writeLineFormat(sb,
			"        $this->set_has_%s();",
			def.Name)
		this.writeLineFormat(sb,
			"        $this->%s = $value;",
			def.Name)
		this.writeLine(sb,
			"    }")
	}
}

func (this *PhpCodeGenerator) writeEnumMapDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	for _, def := range protoDef.EnumMaps {
		this.writeOneEnumMapDecl(sb, def)
	}
}

func (this *PhpCodeGenerator) writeOneEnumMapDecl(
	sb *strings.Builder, enumMapDef *EnumMapDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"final class %s",
		enumMapDef.Name)
	this.writeLine(sb,
		"{")

	for _, def := range enumMapDef.Items {
		if def.Type == EnumMapItemType_Default ||
			def.Type == EnumMapItemType_Int {
			this.writeLineFormat(sb,
				"    const %s = %d;",
				def.Name, def.IntValue)
		} else if def.Type == EnumMapItemType_CurrentEnumRef {
			this.writeLineFormat(sb,
				"    const %s = self::%s;",
				def.Name, def.RefEnumItemDef.Name)
		}
	}
	if len(enumMapDef.Items) > 0 {
		this.writeEmptyLine(sb)
	}

	// name id map
	this.writeLine(sb,
		"    private static $s_name_id_map_ = [")
	for _, def := range enumMapDef.Items {
		if def.RefStructDef == nil {
			continue
		}
		qualifiedName :=
			this.getStructFullQualifiedName(def.RefStructDef)
		qualifiedName = strings.TrimPrefix(qualifiedName, "\\")
		qualifiedName = strings.ReplaceAll(qualifiedName, "\\", "\\\\")
		this.writeLineFormat(sb,
			"        '%s' => %d,",
			qualifiedName, def.IntValue)
	}
	this.writeLine(sb,
		"    ];")

	// id name map
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    private static $s_id_name_map_ = [")
	for _, def := range enumMapDef.Items {
		if def.RefStructDef == nil {
			continue
		}
		qualifiedName :=
			this.getStructFullQualifiedName(def.RefStructDef)
		qualifiedName = strings.TrimPrefix(qualifiedName, "\\")
		qualifiedName = strings.ReplaceAll(qualifiedName, "\\", "\\\\")
		this.writeLineFormat(sb,
			"        %d => '%s',",
			def.IntValue, qualifiedName)
	}
	this.writeLine(sb,
		"    ];")

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public static function getIdByName($name)")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        if (isset(self::$s_name_id_map_[$name])) {")
	this.writeLine(sb,
		"            return self::$s_name_id_map_[$name];")
	this.writeLine(sb,
		"        } else {")
	this.writeLine(sb,
		"            return false;")
	this.writeLine(sb,
		"        }")
	this.writeLine(sb,
		"    }")

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public static function getNameById($id)")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        if (isset(self::$s_id_name_map_[$id])) {")
	this.writeLine(sb,
		"            return self::$s_id_name_map_[$id];")
	this.writeLine(sb,
		"        } else {")
	this.writeLine(sb,
		"            return false;")
	this.writeLine(sb,
		"        }")
	this.writeLine(sb,
		"    }")

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public static function id($obj)")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        $name = get_class($obj);")
	this.writeLine(sb,
		"        return self::getIdByName($name);")
	this.writeLine(sb,
		"    }")

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"    public static function create($id)")
	this.writeLine(sb,
		"    {")
	this.writeLine(sb,
		"        $name = self::getNameById($id);")
	this.writeLine(sb,
		"        if ($name === false) {")
	this.writeLine(sb,
		"            return null;")
	this.writeLine(sb,
		"        }")
	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"        return new $name();")
	this.writeLine(sb,
		"    }")

	this.writeLine(sb,
		"}")
}
