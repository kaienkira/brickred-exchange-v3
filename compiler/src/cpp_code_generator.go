package main

import (
	"fmt"
	"path/filepath"
	"slices"
	"strings"
)

type CppCodeGenerator struct {
	descriptor *ProtocolDescriptor
	newLineStr string
}

func NewCppCodeGenerator() *CppCodeGenerator {
	newObj := new(CppCodeGenerator)

	return newObj
}

func (this *CppCodeGenerator) Close() {
	this.descriptor = nil
}

func (this *CppCodeGenerator) Generate(
	descriptor *ProtocolDescriptor,
	outputDir string, newLineType NewLineType) bool {

	this.descriptor = descriptor
	if newLineType == NewLineType_Dos {
		this.newLineStr = "\r\n"
	} else {
		this.newLineStr = "\n"
	}

	headerFilePath := filepath.Join(
		outputDir, this.descriptor.ProtoDef.Name+".h")
	headerFileContent := this.generateHeaderFile()
	if utilWriteAllText(headerFilePath, headerFileContent) == false {
		return false
	}

	sourceFilePath := filepath.Join(
		outputDir, this.descriptor.ProtoDef.Name+".cc")
	sourceFileContent := this.generateSourceFile()
	if utilWriteAllText(sourceFilePath, sourceFileContent) == false {
		return false
	}

	return true
}

func (this *CppCodeGenerator) writeLine(
	sb *strings.Builder, line string) {

	sb.WriteString(line)
	sb.WriteString(this.newLineStr)
}

func (this *CppCodeGenerator) writeLineFormat(
	sb *strings.Builder, format string, args ...any) {

	fmt.Fprintf(sb, format, args...)
	sb.WriteString(this.newLineStr)
}

func (this *CppCodeGenerator) writeEmptyLine(
	sb *strings.Builder) {

	sb.WriteString(this.newLineStr)
}

func (this *CppCodeGenerator) getEnumItemFullQualifiedName(
	enumItemDef *EnumItemDef) string {

	enumDef := enumItemDef.ParentRef
	protoDef := enumDef.ParentRef
	namespaceDef, ok := protoDef.Namespaces["cpp"]
	if ok && len(namespaceDef.NamespaceParts) > 0 {
		return fmt.Sprintf("%s::%s::%s",
			strings.Join(namespaceDef.NamespaceParts, "::"),
			enumDef.Name,
			enumItemDef.Name)
	} else {
		return ""
	}
}

func (this *CppCodeGenerator) generateHeaderFile() string {
	var sb strings.Builder

	this.writeDontEditComment(&sb)
	this.writeHeaderFileIncludeGuardStart(&sb)
	this.writeHeaderFileIncludeFileDecl(&sb)
	this.writeHeaderFileClassForwardDecl(&sb)
	this.writeNamespaceDeclStart(&sb)
	this.writeHeaderFileEnumDecl(&sb)
	this.writeHeaderFileStructDecl(&sb)
	this.writeNamespaceDeclEnd(&sb)
	this.writeHeaderFileIncludeGuardEnd(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) generateSourceFile() string {
	var sb strings.Builder

	this.writeDontEditComment(&sb)

	return sb.String()
}

func (this *CppCodeGenerator) writeDontEditComment(
	sb *strings.Builder) {

	this.writeLine(sb,
		"/*")
	this.writeLine(sb,
		" * Generated by brickred exchange compiler.")
	this.writeLine(sb,
		" * Do not edit unless you are sure that you know what you are doing.")
	this.writeLine(sb,
		" */")
}

func (this *CppCodeGenerator) writeNamespaceDeclStart(
	sb *strings.Builder) {

	namespaceDef, ok := this.descriptor.ProtoDef.Namespaces["cpp"]
	if ok == false {
		return
	}
	namespaceName := strings.Join(namespaceDef.NamespaceParts, "::")

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"namespace %s {",
		namespaceName)
}

func (this *CppCodeGenerator) writeNamespaceDeclEnd(
	sb *strings.Builder) {

	namespaceDef, ok := this.descriptor.ProtoDef.Namespaces["cpp"]
	if ok == false {
		return
	}
	namespaceName := strings.Join(namespaceDef.NamespaceParts, "::")

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"} // namespace %s",
		namespaceName)
}

func (this *CppCodeGenerator) writeHeaderFileIncludeGuardStart(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	guardNameParts := make([]string, 0)
	guardNameParts = append(guardNameParts, "BRICKRED_EXCHANGE_GENERATED")
	namespaceDef, ok := protoDef.Namespaces["cpp"]
	if ok {
		guardNameParts = append(
			guardNameParts, namespaceDef.NamespaceParts...)
	}
	guardNameParts = append(guardNameParts,
		g_notWordRegexp.ReplaceAllString(protoDef.Name, "_"))
	guardNameParts = append(guardNameParts, "H")
	guardName := strings.ToUpper(strings.Join(guardNameParts, "_"))

	this.writeLineFormat(sb,
		"#ifndef %s",
		guardName)
	this.writeLineFormat(sb,
		"#define %s",
		guardName)
}

func (this *CppCodeGenerator) writeHeaderFileIncludeGuardEnd(
	sb *strings.Builder) {

	this.writeEmptyLine(sb)
	this.writeLine(sb,
		"#endif")
}

func (this *CppCodeGenerator) writeHeaderFileIncludeFileDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef
	useCStdDefH := false
	useCStdIntH := false
	useStringH := false
	useVectorH := false
	useBrickredBaseStructH := false
	useOtherProtoH := false

	if len(protoDef.Structs) > 0 {
		useCStdDefH = true
		useBrickredBaseStructH = true
	}
	if len(protoDef.EnumMaps) > 0 {
		useBrickredBaseStructH = true
	}

	for _, structDef := range protoDef.Structs {
		for _, fieldDef := range structDef.Fields {
			if fieldDef.IsOptional {
				useCStdIntH = true
			}

			checkType := StructFieldType_None
			if fieldDef.Type == StructFieldType_List {
				checkType = fieldDef.ListType
				useVectorH = true
			} else {
				checkType = fieldDef.Type
			}

			if checkType == StructFieldType_I8 ||
				checkType == StructFieldType_U8 ||
				checkType == StructFieldType_I16 ||
				checkType == StructFieldType_U16 ||
				checkType == StructFieldType_I32 ||
				checkType == StructFieldType_U32 ||
				checkType == StructFieldType_I64 ||
				checkType == StructFieldType_U64 ||
				checkType == StructFieldType_I16V ||
				checkType == StructFieldType_U16V ||
				checkType == StructFieldType_I32V ||
				checkType == StructFieldType_U32V ||
				checkType == StructFieldType_I64V ||
				checkType == StructFieldType_U64V {
				useCStdIntH = true
			} else if checkType == StructFieldType_String ||
				checkType == StructFieldType_Bytes {
				useStringH = true
			}
		}
	}

	for _, importDef := range protoDef.Imports {
		if importDef.IsRefByStruct == false &&
			importDef.IsRefByEnumMap {
			continue
		} else {
			useOtherProtoH = true
			break
		}
	}

	if useCStdDefH == false &&
		useCStdIntH == false &&
		useStringH == false &&
		useVectorH == false &&
		useBrickredBaseStructH == false {
		return
	}

	if useCStdDefH || useCStdIntH || useStringH || useVectorH {
		this.writeEmptyLine(sb)
	}
	if useCStdDefH {
		this.writeLine(sb,
			"#include <cstddef>")
	}
	if useCStdIntH {
		this.writeLine(sb,
			"#include <cstdint>")
	}
	if useStringH {
		this.writeLine(sb,
			"#include <string>")
	}
	if useVectorH {
		this.writeLine(sb,
			"#include <vector>")
	}

	if useBrickredBaseStructH || useOtherProtoH {
		this.writeEmptyLine(sb)
	}
	if useBrickredBaseStructH {
		this.writeLine(sb,
			"#include <brickred/exchange/base_struct.h>")
	}
	for _, importDef := range protoDef.Imports {
		if importDef.IsRefByStruct == false &&
			importDef.IsRefByEnumMap {
			continue
		}
		this.writeLineFormat(sb,
			"#include \"%s.h\"",
			importDef.ProtoDef.Name)
	}
}

func (this *CppCodeGenerator) writeHeaderFileClassForwardDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	refStructDefs := make([]*StructDef, 0)
	for _, enumMapDef := range protoDef.EnumMaps {
		for _, enumMapItemDef := range enumMapDef.Items {
			def := enumMapItemDef.RefStructDef
			if def == nil {
				continue
			}
			if def.ParentRef == protoDef {
				continue
			}
			if slices.Contains(refStructDefs, def) {
				continue
			}
			refStructDefs = append(refStructDefs, def)
		}
	}

	if len(refStructDefs) > 0 {
		this.writeEmptyLine(sb)
	}
	for _, refStructDef := range refStructDefs {
		refProtoDef := refStructDef.ParentRef
		refNamespaceDef, ok := refProtoDef.Namespaces["cpp"]
		if ok && len(refNamespaceDef.NamespaceParts) > 0 {
			this.writeLineFormat(sb,
				"namespace %s { class %s; }",
				strings.Join(refNamespaceDef.NamespaceParts, "::"),
				refStructDef.Name)
		} else {
			this.writeLineFormat(sb,
				"class %s;",
				refStructDef.Name)
		}
	}
}

func (this *CppCodeGenerator) writeHeaderFileEnumDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	for _, def := range protoDef.Enums {
		this.writeHeaderFileOneEnumDecl(sb, def)
	}
}

func (this *CppCodeGenerator) writeHeaderFileOneEnumDecl(
	sb *strings.Builder, enumDef *EnumDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"enum class %s {",
		enumDef.Name)

	for _, def := range enumDef.Items {
		if def.Type == EnumItemType_Default {
			this.writeLineFormat(sb,
				"    %s,",
				def.Name)
		} else if def.Type == EnumItemType_Int {
			this.writeLineFormat(sb,
				"    %s = %d,",
				def.Name, def.IntValue)
		} else if def.Type == EnumItemType_CurrentEnumRef {
			this.writeLineFormat(sb,
				"    %s = %s,",
				def.Name, def.RefEnumItemDef.Name)
		} else if def.Type == EnumItemType_OtherEnumRef {
			this.writeLineFormat(sb,
				"    %s = (int)%s,",
				def.Name,
				this.getEnumItemFullQualifiedName(def.RefEnumItemDef))
		}
	}

	this.writeLine(sb,
		"};")
}

func (this *CppCodeGenerator) writeHeaderFileStructDecl(
	sb *strings.Builder) {

	protoDef := this.descriptor.ProtoDef

	for _, def := range protoDef.Structs {
		this.writeHeaderFileOneStructDecl(sb, def)
	}
}

func (this *CppCodeGenerator) writeHeaderFileOneStructDecl(
	sb *strings.Builder, structDef *StructDef) {

	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"class %s : public brickred::exchange::BaseStruct {",
		structDef.Name)
	this.writeLine(sb,
		"public:")
	this.writeLineFormat(sb,
		"    %s();",
		structDef.Name)
	this.writeLineFormat(sb,
		"    ~%s() override;",
		structDef.Name)
	this.writeLineFormat(sb,
		"    void swap(%s &other);",
		structDef.Name)
	this.writeEmptyLine(sb)
	this.writeLineFormat(sb,
		"    static brickred::exchange::BaseStruct *create() { return new %s(); }",
		structDef.Name)
	this.writeLineFormat(sb,
		"    %s *clone() const override { return new %s(*this); }",
		structDef.Name, structDef.Name)
	this.writeLine(sb,
		"    int encode(char *buffer, size_t size) const override;")
	this.writeLine(sb,
		"    int decode(const char *buffer, size_t size) override;")
	this.writeLine(sb,
		"    std::string dump() const override;")
	this.writeLine(sb,
		"};")
}
